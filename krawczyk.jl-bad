using IntervalArithmetic
using AutoDiff

	# center(x) = Interval(mid(x))
	function y(x)
		if differentiate(f, mid(x)) == Interval(0) 
			Interval(1)//(0.00001+Interval(differentiate(f, mid(x))))
		else Interval(1)//Interval(differentiate(f, mid(x)))
		end
	end
	z(x) = 1 - y(x)*differentiate(f, x)
	K(x) = mid(x) - y(x)*f(mid(x)) + z(x)*(x - mid(x))
	do_isect(x, y) = isectext(arr_a[x], arr_b[y])
	
	lower(x::Interval) = Interval(x.lo, mid(x))
	higher(x::Interval) = Interval(mid(x), x.hi)
	
	# Need the function to remove duplicates from an interval array.
	# unique() doesn't seem to work with interval arrays and sort() cannot compare intervals (< or >)
	function undupe(x::Array)
		y = Interval[]
		push!(y, x[1])
		for i = 2:length(x)
			s = 0
			for j = 1:i-1
				if x[i] == x[i-j]
					s += 1
				end
			end
			if s == 0
				push!(y, x[i])
			end			
		end
		y
	end

	x = Ad(a, Interval(1.))

	arr_a = Interval[]
	arr_b = Interval[]

	push!(arr_a, a)

	k = 0
	while k < 20 #true
		
		println(k)
		@show((arr_a, arr_b))
		
		arr_b = Interval[]

		for i = 1:length(arr_a)
			push!(arr_b, K(arr_a[i]))
		end

		arr_a_new = Interval[]

		for i = 1:length(arr_b)
			if do_isect(i, i) != false
				if do_isect(i, i) == arr_a[i]
					arr_a_new = vcat(arr_a_new, isectext(lower(arr_a[i]), arr_b[i]), isectext(higher(arr_a[i]), arr_b[i]))
				else arr_a_new = vcat(arr_a_new, do_isect(i, i))
				end	
			end
		end

		if arr_a_new == arr_a 
			break
		end
		
		arr_a = undupe(arr_a_new)
		k += 1
	end

	println("Function calls: ", k)
	return arr_a
